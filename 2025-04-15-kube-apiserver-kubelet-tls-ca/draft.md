# Что происходит, если --kubelet-certificate-authority не указан?

## Что происходит, когда `kubelet-certificate-authority` не указан у `kube-apiserver`? 
Получается, что API-сервер при выполнении `kubectl exec` не проверяет подпись Kubelet?

**Анализ кода:**

1.  **Парсинг флага:** Флаг `--kubelet-certificate-authority` считывается и его значение (путь к файлу CA) сохраняется в поле `KubeletConfig.TLSClientConfig.CAFile`.
    *   **Код:** [`cmd/kube-apiserver/app/options/options.go:152`](https://vscode.dev/github.com/kubernetes/kubernetes/blob/release-1.32/cmd/kube-apiserver/app/options/options.go#L152-L153)
    ```go
    fs.StringVar(&s.KubeletConfig.TLSClientConfig.CAFile, "kubelet-certificate-authority", s.KubeletConfig.TLSClientConfig.CAFile,
        "Path to a cert file for the certificate authority.")
    ```

2.  **Передача конфигурации:** Эта конфигурация `KubeletConfig` передается в конфигурацию `controlplane.Config` при создании API-сервера.
    *   **Код:** [`cmd/kube-apiserver/app/server.go:229`](https://vscode.dev/github.com/kubernetes/kubernetes/blob/release-1.32/cmd/kube-apiserver/app/server.go#L229-L230)
    ```go
    config := &controlplane.Config{
        // ...
        Extra: controlplane.Extra{
            KubeletClientConfig: opts.KubeletConfig, // Конфигурация Kubelet передается здесь
            // ...
        },
    }
    ```

3.  **Создание транспорта:** Конфигурация `KubeletClientConfig` используется для создания HTTP-транспорта для связи с Kubelet. Ключевая логика находится в функции `transportConfig`.
    *   **Код:** [`pkg/kubelet/client/kubelet_client.go:114-129`](https://vscode.dev/github.com/kubernetes/kubernetes/blob/release-1.32/pkg/kubelet/client/kubelet_client.go#L114-L115)
    ```go
    func (c *KubeletClientConfig) transportConfig() *transport.Config {
        cfg := &transport.Config{
            TLS: transport.TLSConfig{
                CAFile:   c.TLSClientConfig.CAFile, // Используется CAFile из конфигурации
                CertFile: c.TLSClientConfig.CertFile,
                KeyFile:  c.TLSClientConfig.KeyFile,
                // ...
            },
        }
        if !cfg.HasCA() { // Проверка, был ли предоставлен CA-файл
            cfg.TLS.Insecure = true // Если нет, устанавливаем Insecure = true (пропуск проверки)
        }
        return cfg
    }
    ```

**Вывод:**

Если флаг `--kubelet-certificate-authority` не указан, поле `CAFile` в `KubeletClientConfig` будет пустым. Функция `transportConfig` обнаружит это (`!cfg.HasCA()` вернет `true`) и установит `cfg.TLS.Insecure = true`. Это приведет к тому, что HTTP-клиент, используемый API-сервером для связи с Kubelet, будет пропускать проверку TLS-сертификата Kubelet.

Следовательно, API-сервер **не будет проверять** подлинность Kubelet по его сертификату при выполнении операций вроде `kubectl exec`, `logs` или `port-forward`, если `--kubelet-certificate-authority` не указан.

## И че?

Как мы выяснили из анализа кода, если флаг `--kubelet-certificate-authority` не указан, `kube-apiserver` устанавливает `Insecure = true` для TLS-соединения с Kubelet. Это означает, что **API-сервер не проверяет TLS-сертификат, предъявляемый Kubelet'ом**.

### Уязвимость Man-in-the-Middle (MITM)

Это создает прямую уязвимость для атаки Man-in-the-Middle (MITM). Если злоумышленник сможет перенаправить трафик от `kube-apiserver` к Kubelet на свой подконтрольный узел (например, через ARP spoofing, DNS poisoning, BGP hijacking или просто неверную конфигурацию сети/маршрутизации), он сможет выдать себя за легитимный Kubelet.

Поскольку `kube-apiserver` не проверяет сертификат, он установит TLS-соединение с поддельным Kubelet'ом. Весь трафик, который `kube-apiserver` проксирует к Kubelet (например, для команд `kubectl exec`, `kubectl logs`, `kubectl port-forward`), будет проходить через злоумышленника.

### Сценарии атаки

Атака обычно состоит из двух этапов: получение возможности перенаправить трафик и эксплуатация этого перенаправления.

**Этап 1: Получение контроля над трафиком**

1.  **Компрометация сети/промежуточного узла:** Злоумышленник получает контроль над сетевым маршрутом между `kube-apiserver` и Kubelet'ами. Это может быть достигнуто разными способами:
    *   Атаки на уровне сети (например, **ARP spoofing**, **DNS poisoning/rebinding**, **BGP hijacking**).
    *   Неверная конфигурация маршрутизации или правил **iptables** на сетевом оборудовании или узлах.
    *   Компрометация узла, через который проходит трафик.

2.  **Компрометация Control Plane узла:** Получив доступ к узлу Control Plane (где работает `kube-apiserver`), атакующий может напрямую изменить его локальную таблицу маршрутизации или правила `iptables`, чтобы перенаправить трафик, предназначенный для легитимных Kubelet'ов, на свой подконтрольный адрес. Это более прямой способ добиться перенаправления трафика.

3.  **Введение в кластер фейковой ноды (менее прямой сценарий):** Злоумышленник добавляет в кластер свою "ноду". *Примечание: Этот сценарий в первую очередь требует компрометации механизма регистрации нод (например, кражи bootstrap-токенов или компрометации CA Kubelet'ов), а не отсутствия флага `--kubelet-certificate-authority`. Однако, если фейковая нода успешно добавлена, отсутствие проверки сертификата API-сервером при `exec/logs` может помочь скрыть следы или облегчить дальнейшие действия.*

**Этап 2: Эксплуатация (после успешного перенаправления трафика)**

4.  **Подмена Kubelet:** Злоумышленник запускает свой сервис, имитирующий Kubelet API, на узле, куда был перенаправлен трафик (см. Этап 1).
5.  **Перехват сессии:** Легитимный пользователь выполняет команду, требующую взаимодействия с Kubelet, например, `kubectl exec -it my-pod -- /bin/bash`.
6.  **Выполнение команд:** `kube-apiserver`, не проверяя сертификат Kubelet'а из-за отсутствия `--kubelet-certificate-authority`, подключается к поддельному Kubelet'у злоумышленника. Злоумышленник получает полный контроль над сессией: он может перехватывать вводимые команды, видеть выводимые данные (включая секреты) и выполнять свои команды в контейнере от имени пользователя.

### Почему это важно?

Хотя для эксплуатации этой уязвимости требуется предварительная компрометация сети или узла, она значительно расширяет возможности атакующего. Получив возможность перехватывать `kubectl exec/logs`, злоумышленник может:

*   Получить доступ к чувствительным данным внутри контейнеров.
*   Выполнять произвольные команды в контейнерах, потенциально повышая привилегии или перемещаясь дальше по системе.
*   Нарушить работу приложений.

### Насколько это страшно на практике?

Давайте оценим реальный риск. Хотя технически MITM возможен, его эксплуатация требует от атакующего преодоления нескольких барьеров:

1.  **Доступ к сети:** Самое главное – злоумышленнику нужен способ перехватить или перенаправить трафик между `kube-apiserver` и Kubelet'ами. Это подразумевает либо компрометацию сетевой инфраструктуры (маршрутизаторы, коммутаторы), либо узла в том же сегменте сети, откуда можно провести ARP/DNS spoofing. В изолированных, сегментированных сетях (например, отдельный VLAN для control plane) это значительно сложнее.
2.  **Обход Network Policies:** Если в кластере настроены Network Policies, которые разрешают Kubelet'у принимать соединения только от `kube-apiserver` (по IP или лейблам), то поддельный Kubelet злоумышленника просто не сможет получить соединение от API-сервера.
3.  **Права на узле:** Даже если атакующий может перенаправить трафик, ему нужно запустить свой поддельный Kubelet-сервис на каком-то узле, что опять же требует определенного уровня компрометации.

**Вывод по риску:** В средах с хорошей сетевой гигиеной (сегментация, фаерволы, Network Policies) и контролем доступа к узлам, риск успешной эксплуатации этой уязвимости **снижается**. Она становится актуальной в основном если атакующий *уже* получил значительный доступ к вашей инфраструктуре. Тем не менее, это не отменяет того факта, что проверка сертификата Kubelet'а – это важный слой защиты (defense-in-depth), который стоит включить.


## Как исправить?

Необходимо явно указать `kube-apiserver`, какому центру сертификации (CA) доверять при проверке сертификатов Kubelet.

1.  **Убедитесь, что Kubelet'ы используют TLS-сертификаты:** Обычно это настраивается при установке кластера (например, через `kubeadm`). Сертификаты Kubelet должны быть подписаны определенным CA.
2.  **Укажите CA для `kube-apiserver`:** Добавьте флаг `--kubelet-certificate-authority` к команде запуска `kube-apiserver`, указав путь к файлу CA-сертификата, которым подписаны сертификаты Kubelet. Обычно это тот же CA, что используется для всего кластера.
    ```yaml
    # Пример для манифеста static pod kube-apiserver
    spec:
      containers:
      - command:
        - kube-apiserver
        # ... другие флаги
        - --kubelet-certificate-authority=/etc/kubernetes/pki/ca.crt
        # ... другие флаги
    ```
3.  **Проверьте конфигурацию:** После внесения изменений перезапустите `kube-apiserver` и убедитесь, что команды `kubectl exec`, `logs` и т.д. продолжают работать.

## Вывод

Отсутствие флага `--kubelet-certificate-authority` у `kube-apiserver` — это реальная брешь в безопасности, которая открывает вектор для MITM-атак на соединения между API-сервером и Kubelet'ами. Хотя успешная эксплуатация требует предварительной компрометации сети или узлов, устранение этой бреши является важным элементом эшелонированной защиты (defense-in-depth). Настоятельно рекомендуется всегда указывать этот флаг и обеспечивать строгую проверку TLS-сертификатов Kubelet в production-окружениях.


